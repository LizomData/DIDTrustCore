package vulnerabilityScanningController

import (
	"DIDTrustCore/common"
	"DIDTrustCore/controller/sbomController"
	"DIDTrustCore/model/requestBase"
	"DIDTrustCore/util/dataBase"
	"DIDTrustCore/util/dataBase/scanReportDb"
	"DIDTrustCore/util/grype/grypeService"
	"fmt"
	"github.com/gin-gonic/gin"
	"time"
)

// @Summary 生成分析漏洞接口
// @Description 根据已经生成的sbom生成漏洞分析报告
// @Tags 漏洞分析
// @Accept json
// @Produce json
// @Param Authorization	header		string	true	"jwt"
// @Param body body ScanRequest true "分析参数"
// @Success 200 {object} model.ScanReport "SBOM清单信息"
// @Router /api/v1/vulnerability/scan [post]
func scan(c *gin.Context) {
	var req ScanRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(requestBase.ResponseBody(requestBase.ParameterError, "无效的请求参数", gin.H{}))
		return
	}
	report, err := dataBase.Sbom_svc.GetSBOMByID(req.SbomReportId)
	if err != nil {
		c.JSON(requestBase.ResponseBody(requestBase.NotSbomReport, "查询sbom_report错误:"+err.Error(), gin.H{}))
		return
	}
	sbomPath := sbomController.Generator.Config.SBOMStorageDir + "/" + report.SBOMFilename
	// 生成唯一文件名
	reportFilename := fmt.Sprintf("report_%d_%d.json", time.Now().UnixNano(),
		time.Now().Nanosecond())

	if err := grypeService.Service.RunGrypeWrapper(reportFilename, sbomPath); err != nil {
		c.JSON(requestBase.ResponseBody(requestBase.NotSbomReport, "分析漏洞:"+err.Error(), gin.H{}))
		return
	}

	user, _ := common.GetUserFromContext(c)
	record, err := scanReportDb.Svc.CreateRecord(user.ID, reportFilename, grypeService.Service.Config.PublicPath+reportFilename)
	if err != nil {
		c.JSON(requestBase.ResponseBody(requestBase.NotSbomReport, "保存记录错误:"+err.Error(), gin.H{}))
		return
	}
	c.JSON(requestBase.ResponseBodySuccess(record))

}
